#!/usr/bin/env python3

import argparse
import os
import sys
from pathlib import Path
from collections import defaultdict
import json

def parse_ninja_log(log_path):
    """
    Parses .ninja_log file.
    Format: start_time \t end_time \t mtime \t output_path \t command_hash
    Times are in milliseconds since some epoch (or relative to build start, but usually epoch).
    """
    tasks = []
    with open(log_path, 'r') as f:
        header = f.readline() # Skip header
        for line in f:
            parts = line.strip().split('\t')
            if len(parts) < 4:
                continue
            start, end, _, output, _ = parts[:5]
            tasks.append({
                'start': int(start),
                'end': int(end),
                'output': output
            })
    return tasks

def identify_subproject(output_path):
    """
    Identifies the sub-project from the output path.
    Examples:
    base/rocm-cmake/stamp/configure.stamp -> base/rocm-cmake
    compiler/amd-llvm/build/CMakeCache.txt -> compiler/amd-llvm
    third-party/boost/therock-boost -> third-party/boost
    """
    parts = output_path.split('/')
    if len(parts) >= 2:
        # Check for common patterns
        if parts[0] in ['base', 'compiler', 'core', 'comm-libs', 'dctools', 'profiler', 'third-party']:
            if parts[0] == 'third-party' and parts[1] == 'sysdeps':
                 if len(parts) >= 4:
                     return f"{parts[0]}/{parts[1]}/{parts[2]}/{parts[3]}"
                 return f"{parts[0]}/{parts[1]}"
            return f"{parts[0]}/{parts[1]}"
    return "other"

def analyze_tasks(tasks):
    projects = defaultdict(lambda: {'start': float('inf'), 'end': 0, 'duration_sum': 0, 'tasks': []})
    
    for task in tasks:
        subproj = identify_subproject(task['output'])
        if subproj == 'other':
            continue
            
        duration = task['end'] - task['start']
        
        p = projects[subproj]
        p['start'] = min(p['start'], task['start'])
        p['end'] = max(p['end'], task['end'])
        p['duration_sum'] += duration
        p['tasks'].append(task)
        
    results = []
    for name, data in projects.items():
        total_time = data['end'] - data['start']
        results.append({
            'name': name,
            'start': data['start'],
            'end': data['end'],
            'total_time': total_time,
            'cumulative_time': data['duration_sum'],
            'task_count': len(data['tasks'])
        })
        
    # Sort by start time
    results.sort(key=lambda x: x['start'])
    return results

def generate_html(results, output_file):
    html_template = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TheRock Build Time Analysis</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 20px; background-color: #f4f4f9; color: #333; }
        h1 { text-align: center; color: #2c3e50; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); background-color: white; }
        th, td { padding: 12px 15px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background-color: #3498db; color: white; }
        tr:hover { background-color: #f1f1f1; }
        .bar-container { width: 100%; background-color: #e0e0e0; border-radius: 4px; height: 20px; position: relative; }
        .bar { height: 100%; background-color: #2ecc71; border-radius: 4px; position: absolute; }
        .duration { font-weight: bold; color: #27ae60; }
        .footer { margin-top: 30px; text-align: center; font-size: 0.9em; color: #777; }
    </style>
</head>
<body>
    <h1>TheRock Build Time Analysis</h1>
    <table>
        <thead>
            <tr>
                <th>Sub-Project</th>
                <th>Start Time (ms)</th>
                <th>End Time (ms)</th>
                <th>Total Duration (s)</th>
                <th>Cumulative CPU Time (s)</th>
                <th>Timeline (Relative)</th>
            </tr>
        </thead>
        <tbody>
            {rows}
        </tbody>
    </table>
    <div class="footer">Generated by analyze_build_times.py</div>
</body>
</html>
    """
    
    if not results:
        print("No results to generate HTML.")
        return

    min_start = min(r['start'] for r in results)
    max_end = max(r['end'] for r in results)
    total_span = max_end - min_start
    
    rows = ""
    for r in results:
        relative_start = (r['start'] - min_start) / total_span * 100
        relative_width = (r['end'] - r['start']) / total_span * 100
        
        rows += f"""
            <tr>
                <td>{r['name']}</td>
                <td>{r['start']}</td>
                <td>{r['end']}</td>
                <td class="duration">{r['total_time'] / 1000:.2f}</td>
                <td>{r['cumulative_time'] / 1000:.2f}</td>
                <td>
                    <div class="bar-container">
                        <div class="bar" style="left: {relative_start}%; width: {relative_width}%;"></div>
                    </div>
                </td>
            </tr>
        """
        
    try:
        with open(output_file, 'w') as f:
            f.write(html_template.replace("{rows}", rows))
    except Exception as e:
        print(f"Error writing file: {e}")
        return
    print(f"HTML report generated at: {output_file}")

def main():
    parser = argparse.ArgumentParser(description="Analyze Ninja build times")
    parser.add_argument("--build-dir", type=Path, required=True, help="Path to build directory")
    parser.add_argument("--output", type=Path, help="Path to output HTML file")
    args = parser.parse_args()
    
    ninja_log = args.build_dir / ".ninja_log"
    if not ninja_log.exists():
        print(f"Error: {ninja_log} not found.")
        sys.exit(1)
        
    tasks = parse_ninja_log(ninja_log)
    results = analyze_tasks(tasks)
    
    if args.output:
        output_html = args.output
    else:
        output_html = args.build_dir / "logs" / "build_time_analysis.html"
        # Ensure logs dir exists
        output_html.parent.mkdir(parents=True, exist_ok=True)
    
    generate_html(results, output_html)

if __name__ == "__main__":
    main()
